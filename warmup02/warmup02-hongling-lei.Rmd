---
title: "warmup02-hongling-lei"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
# 1) Vectors
```{r}
number = as.integer(c(30, 35, 23, 9, 11, 27, 34, 6, 3, 0))
player = c("Stephen Curry", "Kevin Durant", "Draymond Green", "Andre Iguodala", "Klay Thompson", 
           "Zaza Pachulia", "Shaun Livingston", "Nick Young", "David West", "Patrick McCaw")
position = factor(as.character(c("PG", "PF", "PF", "SF", "SG", "C", "PG", "SG", "C", "SG")))
height = as.character(c("6-3", "6-9", "6-7", "6-6", "6-7", "6-11", "6-7", "6-7", "6-9", "6-7"))
weight = as.double(c(190, 240, 230, 215, 215, 270, 192, 210, 250, 185))
birthdate = c("March 14, 1988", "September 29, 1988", "March 4, 1990", "January 28, 1984",
             "February 8, 1990", "February 10, 1984", "September 11, 1985", "June 1, 1985", 
             "August 29, 1980", "October 25, 1995")
experience = as.integer(c(8, 10, 5, 13, 6, 14, 12, 10, 14, 1))
college = c("Davidson College", "University of Texas at Austin", "Michigan State University",
            "University of Arizona", "Washington State University", "NA", "NA", 
            "University of Southern California", "Xavier University", "University of Nevada, Las Vegas")
```

```{r}
player[which.max(weight)]
```
a) The heaviest player is named __Zaza Pachulia__.

```{r}
college[height == '6-6']
```
b) The college of the player that has a height of 6-6 is __University of Arizona__.

```{r}
position[which.max(experience)]
```
c) The position of players with more years of experience is __C__.

```{r}
number[which.min(weight)]
```
d) The number of the lightest player is __0__.

```{r}
table(position)
```
e) The frequencies of the position values are above.

```{r}
sum(table(number[weight > mean(weight)]))
```
f) __Four__ players have a weight larger than the average weight.

```{r}
sum(table(number[experience >= 9 & experience <=12]))
```
g) __Three__ players have between 9 and 12 years of experience (inclusive).

```{r}
mean(experience[position == 'SG'])
```
h) The mean years of experience of Shooting Guard players is __5.666667__

```{r}
median(weight[position != 'C'])
```
i) The median weight of those players with a position different of Center(C) is __212.5__

```{r}
quantile(experience[position == 'PF' | position == 'SG'])
```
j) The first quartile is __5__.



# 2) List for GSW
```{r}
gsw <- list(
  player = player,
  number = number,
  position = position,
  weight = weight,
  experience = experience
)
```
```{r}
gsw <- list(
  player = player,
  number = number,
  position = position,
  weight = weight,
  experience = experience
)
subset(gsw$number, gsw$weight == max(gsw$weight))
```
a) The number of the heaviest player is __27__.

```{r}
subset(gsw$position, gsw$experience == min(gsw$experience))
```
b) The position of the player with less experience is __SG__.

```{r}
library(plyr)
sum(table(subset(gsw$player, gsw$experience<8 | gsw$experience>11)))
```
c) __Seven__ players have less than 8 or more than 11 years of experience.

```{r}
quantile(subset(gsw$experience, gsw$position == 'PF' | gsw$position == 'SG'))
```
d) The third quartile is __10__.

```{r}
gsw$diff = (gsw$weight - mean(gsw$weight))
subset(gsw$player, gsw$diff == max(gsw$diff))
```
e) The player whose weight is furthest from the average weight (of all players) is named __Zaza Pachulia__.


# 3) More Lists
```{r}
hp <- list(
  first = 'Harry',
  last = 'Potter',
  courses = c('Potions', 'Enchantments', 'Spells'), 
  sport = 'quidditch',
  age = 18L,
  gpa = 3.9
)
class(hp)
```
a) The class of hp is __"list"__.

```{r}
length(hp)
```
b) __Six__ elements are in the list.

```{r}
length(hp$courses)
```
c) The length of courses is __3__.

```{r}
typeof(hp$age)
```
d) The data type of age is __integer__.

```{r}
typeof(hp$gpa)
```
e) The data type of gpa is __double__.

```{r}
NewVec <- c(hp$age, hp$gpa)
typeof(NewVec)
```
f) The type of the new vector is __double__.


# 4) Technical Questions
a) Coercion.\
Because 1 is a number and TRUE is a logical element whose value equals 1. When you call a function with an argument of the wrong type, R will try to coerce values to a different type so that the function will work.\
In this case, 1 and TRUE are of different types but R automatically transforms the logical vector into a numerical number.

```{r}
"-2" > 0
"2" > 0
typeof("-2")
typeof(0)
```
b) Although "-2" is a character while 0 is a double, they are all transformed/coerced as double when R tries to compare them. Since -2 > 0 is mathematically wrong, the running result is FALSE.\
To check that the FALSE isn't because we are comparing two different types of data, I run "2" > 0 and the result is TRUE.

c) By running (10 <= 5) >= 0 we get TRUE because R first run (10 <= 5) and this part generates a FALSE, which equals 0 in number. Then R compares 0 with 0. Since 0 >= 0, the final result is TRUE.

```{r}
# command A
1 + !TRUE
# command B
!TRUE + 1
```
d) They are different because of the order of calculation and coercion.\
Command A generates 1 because 1 appears first, so the later !TRUE is transformed to integer; since !TRUE means FALSE, it has the value 0. Therefore, 1 + !TRUE = 1 + 0 = 1.\
Command B generates FALSE because !TRUE appears first as a logical element, so the command basically equals !(TRUE + 1); the later 1 is coerced as TRUE. The command is then treated as !(TRUE + TRUE), with the "+" meaning "and", so it gets !(TRUE) and then gets FALSE.


# 5) Subsetting
```{r}
lord <- c('v', 'o', 'l', 'd', 'e', 'm', 'o', 'r', 't')
lord[TRUE]
```
a) Subsetting and recycling.\
To do logical subsetting, the vector that we put inside the brackets should match the length of the manipulated vector. __If we pass a shorter vector inside brackets, R will apply its recycling rules.__\
So in this command, there's only one logical value inside the bracket, so it automatically recycles and creates three other *TRUE*s. Then *lord[TRUE]* equals *lord[c(TRUE, TRUE, TRUE, TRUE)], and displays all the elements in lord.

```{r}
lord[length(lord) + 1]
```
b) Subsetting. length(lord) = 9, so *length(lord) + 1* = 10. Then the command becomes lord[10], but there are only 9 elements in it, so the result is NA because there's no such the 10th element.

```{r}
lord[seq(from = length(lord), to = 1, by = -2)]
```
c) Subsetting.\
   *seq(from =  length(lord), to = 1, by = -2)*
   -> seq(from = 9, to = 1, by = -2)\
   -> 9, 7, 5, 3, 1\
   -> the original command is equal to: \
   -> lord[9], lord[7], lord[5], lord[3], lord[1]\
   -> "t", "o", "e", "l", "v"
   
```{r}
lord[lord == "o"]
```
d) Subsetting with logical indices.\
*lord == "o"* get us *FALSE TRUE FALSE FALSE FALSE FALSE TRUE FALSE FALSE*, and *lord[]* only displays those with a *TRUE* position. So only *lord[2]* and *lord[7]* are displayed, which are *"o" and "o"*.

```{r}
lord[lord != "e" & lord != "o"]
```
e) Subsetting with logical indices.\
We can see the command inside the bracket as a condition to satisfy if we want the outer command to work. *lord !="e" & lord != "o"* means that the element cannot be "e" nor "o". Therefore, the remaining elements after excluding "e" and "o" are "v", "l", "d", "m", "r" and "t".

```{r}
lord[lord %in% c('a', 'e', 'i', 'o', 'u')]
```
f) Subsetting. *%in%* is a tool to search whether the vectors before and after *%in%* have any overlap. In this example, "voldemort" and "aeiou" have "e" and "o" in common, so the result displays all "e"s and "o"s in the vector lord; first appear, first display. So we get "o", "e", "o".
```{r}
lord %in% c('a', 'e', 'i', 'o', 'u')
```
f) (Cont.) Alternatively, we can think this way: R runs the inner command *lord %in% c('a', 'e', 'i', 'o', 'u')* first, and we get *FALSE TRUE FALSE FALSE TRUE FALSE TRUE FALSE FALSE*, then under the outer command *lord*, only the elements in *TRUE* positions are displayed, which are "o", "e", "o".

```{r}
toupper(lord[!(lord %in% c('a', 'e', 'i', 'o', 'u'))])
```
g) Subsetting.\
   step 1: run *lord %in% c('a', 'e', 'i', 'o', 'u')* and get *FALSE TRUE FALSE FALSE TRUE FALSE TRUE FALSE FALSE*\
   step 2: with the *!* ahead, we get the inverse logical vector *TRUE FALSE TRUE TRUE FALSE TRUE FALSE TRUE TRUE*\
   step 3: with *lord[]* outside, we then get *"v" "l" "d" "m" "r" "t"*\
   step 4: with *toupper[]* outside, R present all the results in upper case, so we finally get *"V" "L" "D" "M" "R" "T"*

```{r}
paste(lord, collapse = '')
```
h) *paste(collapse)* puts seperate elements in a vector together, and *''* is the interval, which is basically no interval here.\
So the letters are put together without any space between one another.

```{r}
lord[is.na(lord)]
```
i) Subsetting. Running *is.na(lord)* gives us *FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE*;\
   So with *lord[]* outside, no element will be displayed; the character length is 0.

```{r}
sum(!is.na(lord))
```
j) Subsetting and coercion.\
   Running *is.na(lord)* gives us *FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE*;\
   With a *!* ahead, we get the inverse *TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE*.\
   With *sum()* ahead, R automatically turns logical vectors into numbers (coercion), i.e. *1 1 1 1 1 1 1 1 1*.
   So we get sum = 9.


# 6) 2D Arrays
```{r}
vol <- matrix(lord, nrow = 3, ncol = 3)
vol
```
a)
```{r}
vol[1,]
```
b)
```{r}
vol[1:2, 2:1]
```
c)
```{r}
mat6 <- vol[3:1, 1:3] 
# I named it mat6 because I didn't realize that I would use this matrix until I alrealdy named mat5
mat6
```
d)
```{r}
matrix(c(vol[,1], vol[,2], vol[,2]), nrow = 3, ncol = 3)
```
e)
```{r}
mat1 <- matrix(c(vol[,3], vol[,2], vol[,1]), nrow = 3, ncol = 3)
mat2 <- matrix(c(mat1[3,], mat1[2,], mat1[1,]), nrow = 3, ncol = 3, byrow = TRUE)
mat2
```
f)
```{r}
mat3 <- matrix(c(mat2[,1], mat2[,2]), nrow = 3)
```
```{r}
mat4 <- matrix(c(mat1[1,], mat1[2,], mat1[3,]), nrow = 3, ncol = 3, byrow = TRUE)
```
```{r}
mat5 <- matrix(c(mat3[,1], mat4[,1], mat3[,2], mat4[,2], mat3[,2], mat4[,2], mat3[,1], mat4[,1]), ncol = 4)
mat5
```
g)
```{r}
mat7 <- matrix(c(vol[,1], vol[,2], vol[,3]), nrow = 3, ncol = 3)
mat8 <- matrix(c(mat6[,1], mat7[,1], mat6[,2], mat7[,2], mat6[,3], mat7[,3]), ncol = 3)
mat9 <- matrix(c(mat8[,1], mat8[,2], mat8[,3], mat8[,3], mat8[,2], mat8[,1]), ncol = 6)
mat9
```
